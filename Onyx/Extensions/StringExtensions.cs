using System.Runtime.CompilerServices;
using System.Text;
using Onyx.Html;

namespace Onyx.Extensions
{
	public static class StringExtensions
	{
		#region C-style backslash escaping

		// OMG how many times have I written these methods >_<

		/// <summary>
		/// Replace unsafe characters within the string with C-style backslash escape sequences.<br />
		/// <br />
		/// Characters in the range of [7, 13] will be replaced with their C-style named escapes, like
		/// '\t' and '\n'; the special characters apostrophe, quote, and backslash will all be preceded
		/// with a backslash; and all other byte values less than 32 or greater than 126 will be replaced
		/// with a hexadecimal escape sequence, like '\x1E' or '\u2021'.  Note that the common (but not
		/// C-compatible) escape code '\e' is <em>not</em> generated by this function; the output of this
		/// is strictly compatible with C's encoding.
		/// </summary>
		/// <param name="str">The string to add C-style slashes to.</param>
		/// <returns>The safely-escaped string.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string AddCSlashes(this string str)
			=> AddCSlashes(str.AsSpan());

		/// <summary>
		/// Replace unsafe characters within the string with C-style backslash escape sequences.<br />
		/// <br />
		/// Characters in the range of [7, 13] will be replaced with their C-style named escapes, like
		/// '\t' and '\n'; the special characters apostrophe, quote, and backslash will all be preceded
		/// with a backslash; and all other byte values less than 32 or greater than 126 will be replaced
		/// with a hexadecimal escape sequence, like '\x1E' or '\u2021'.  Note that the common (but not
		/// C-compatible) escape code '\e' is <em>not</em> generated by this function; the output of this
		/// is strictly compatible with C's encoding.
		/// </summary>
		/// <param name="str">The string to add C-style slashes to.</param>
		/// <returns>The safely-escaped string.</returns>
		public static string AddCSlashes(this ReadOnlySpan<char> str)
		{
			if (str.Length == 0)
				return string.Empty;

			int i, length = str.Length;

			StringBuilder stringBuilder = new StringBuilder(length);

			for (i = 0; i < length; i++)
			{
				char ch = str[i];
				if (ch < 32)
				{
					switch ((int)ch)
					{
						case 7: stringBuilder.Append("\\a"); break;
						case 8: stringBuilder.Append("\\b"); break;
						case 9: stringBuilder.Append("\\t"); break;
						case 10: stringBuilder.Append("\\n"); break;
						case 11: stringBuilder.Append("\\v"); break;
						case 12: stringBuilder.Append("\\f"); break;
						case 13: stringBuilder.Append("\\r"); break;
						default:
							stringBuilder.AppendFormat("\\x{0:X2}", (int)ch);
							break;
					}
				}
				else if (ch >= 127)
				{
					if (ch >= 256)
						stringBuilder.AppendFormat("\\u{0:X4}", (int)ch);
					else
						stringBuilder.AppendFormat("\\x{0:X2}", (int)ch);
				}
				else if (ch == '\'' || ch == '\"' || ch == '\\')
				{
					stringBuilder.Append('\\');
					stringBuilder.Append(ch);
				}
				else
				{
					stringBuilder.Append(ch);
				}
			}

			return stringBuilder.ToString();
		}

		/// <summary>
		/// Replace backslash-escaped characters within a string with their equivalent C-style
		/// backslash-escape-sequence values.<br />
		/// <br />
		/// This recognizes all of the standard C-style named escape sequences, like '\t' and '\n',
		/// as well as C-style numeric escape sequences, like '\13' and '\0' (which will be treated
		/// as decimal values), and C-style hexadecimal escape sequences, like '\x1E'.  This also
		/// recognizes the common (but nonstandard) '\e' escape to mean the value 27; and the
		/// common (but nonstandard) '\uXXXX' escape to mean 16-bit Unicode values.
		/// </summary>
		/// <param name="str">The string to decode C-style slashes from.</param>
		/// <returns>The unescaped string.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string StripCSlashes(this string str)
			=> StripCSlashes(str.AsSpan());

		/// <summary>
		/// Replace backslash-escaped characters within a string with their equivalent C-style
		/// backslash-escape-sequence values.<br />
		/// <br />
		/// This recognizes all of the standard C-style named escape sequences, like '\t' and '\n',
		/// as well as C-style numeric escape sequences, like '\13' and '\0' (which will be treated
		/// as decimal values), and C-style hexadecimal escape sequences, like '\x1E'.  This also
		/// recognizes the common (but nonstandard) '\e' escape to mean the value 27; and the
		/// common (but nonstandard) '\uXXXX' escape to mean 16-bit Unicode values.
		/// </summary>
		/// <param name="str">The string to decode C-style slashes from.</param>
		/// <returns>The unescaped string.</returns>
		public static string StripCSlashes(this ReadOnlySpan<char> str)
		{
			if (str.Length == 0)
				return string.Empty;

			int length = str.Length;
			StringBuilder result = new StringBuilder();

			for (int i = 0; i < length;)
			{
				char ch;
				if ((ch = str[i++]) != '\\')
				{
					result.Append(ch);
					continue;
				}
				if (i >= length)
					continue;

				switch (ch = str[i])
				{
					case 'a': result.Append((char)7); i++; break;
					case 'b': result.Append((char)8); i++; break;
					case 't': result.Append((char)9); i++; break;
					case 'n': result.Append((char)10); i++; break;
					case 'v': result.Append((char)11); i++; break;
					case 'f': result.Append((char)12); i++; break;
					case 'r': result.Append((char)13); i++; break;
					case 'e': result.Append((char)27); i++; break;

					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
						{
							int value = ch - '0';
							i++;

							if (i < length && (ch = str[i]) >= '0' && ch <= '9')
							{
								value *= 10;
								value += ch - '0';
								i++;

								if (i < length && (ch = str[i]) >= '0' && ch <= '9')
								{
									value *= 10;
									value += ch - '0';
									i++;
								}
							}

							result.Append((char)(value & 0xFF));
							break;
						}

					case 'x':
						{
							i++;
							int value;
							(value, i) = DecodeHexEscape(str, i, 2);
							result.Append((char)(value & 0xFF));
							break;
						}

					case 'u':
						{
							i++;
							int value;
							(value, i) = DecodeHexEscape(str, i, 4);
							result.Append((char)(value & 0xFF));
							break;
						}

					default:
						result.Append(ch);
						i++;
						break;
				}

				static (int, int) DecodeHexEscape(ReadOnlySpan<char> str, int ptr, int max)
				{
					int value = 0;
					int count = 0;

					while (ptr < str.Length && count < max)
					{
						char ch;
						if ((ch = str[ptr]) >= '0' && ch <= '9')
						{
							ptr++;
							count++;
							value = (value << 4) | (ch - '0');
						}
						else if (ch >= 'a' && ch <= 'f')
						{
							ptr++;
							count++;
							value = (value << 4) | (ch - 'a' + 10);
						}
						else if (ch >= 'A' && ch <= 'F')
						{
							ptr++;
							count++;
							value = (value << 4) | (ch - 'A' + 10);
						}
						else break;
					}

					return (value, ptr);
				}
			}

			return result.ToString();
		}

		#endregion

		#region HTML entities

		/// <summary>
		/// Replace all characters in the given string that have equivalent HTML entities
		/// with their equivalent HTML entity.  The output string will be a pure-ASCII
		/// representation of the same input text.
		/// </summary>
		/// <param name="str">The string to encode.</param>
		/// <returns>The resulting encoded string.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string HtmlEncode(this string str)
			=> HtmlEntities.Escape(str);

		/// <summary>
		/// Replace all characters in the given string that have equivalent HTML entities
		/// with their equivalent HTML entity.  The output string will be a pure-ASCII
		/// representation of the same input text.
		/// </summary>
		/// <param name="str">The string to encode.</param>
		/// <returns>The resulting encoded string.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string HtmlEncode(this ReadOnlySpan<char> str)
			=> HtmlEntities.Escape(str);

		/// <summary>
		/// Replace all characters in the given string that have equivalent HTML entities
		/// with their equivalent HTML entity.  The output string will be a pure-ASCII
		/// representation of the same input text.
		/// </summary>
		/// <param name="str">The string to encode.</param>
		/// <param name="dest">The resulting encoded string will be written to this StringBuilder.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void HtmlEncodeTo(this string str, StringBuilder dest)
			=> HtmlEntities.EscapeTo(str, dest);

		/// <summary>
		/// Replace all characters in the given string that have equivalent HTML entities
		/// with their equivalent HTML entity.  The output string will be a pure-ASCII
		/// representation of the same input text.
		/// </summary>
		/// <param name="str">The string to encode.</param>
		/// <param name="dest">The resulting encoded string will be written to this StringBuilder.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void HtmlEncode(this ReadOnlySpan<char> str, StringBuilder dest)
			=> HtmlEntities.EscapeTo(str, dest);

		/// <summary>
		/// Replace all HTML entities in the given string with their equivalent actual character.
		/// The output string will be a fully-decoded equivalent of the same input text.
		/// </summary>
		/// <param name="str">The string to decode.</param>
		/// <returns>The resulting decoded string.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string HtmlDecode(this string str)
			=> HtmlEntities.Unescape(str);

		/// <summary>
		/// Replace all HTML entities in the given string with their equivalent actual character.
		/// The output string will be a fully-decoded equivalent of the same input text.
		/// </summary>
		/// <param name="str">The string to decode.</param>
		/// <returns>The resulting decoded string.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string HtmlDecode(this ReadOnlySpan<char> str)
			=> HtmlEntities.Unescape(str);

		/// <summary>
		/// Replace all HTML entities in the given string with their equivalent actual character.
		/// The output string will be a fully-decoded equivalent of the same input text.
		/// </summary>
		/// <param name="str">The string to decode.</param>
		/// <param name="dest">The resulting encoded string will be written to this StringBuilder.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void HtmlDecodeTo(this string str, StringBuilder dest)
			=> HtmlEntities.UnescapeTo(str, dest);

		/// <summary>
		/// Replace all HTML entities in the given string with their equivalent actual character.
		/// The output string will be a fully-decoded equivalent of the same input text.
		/// </summary>
		/// <param name="str">The string to decode.</param>
		/// <param name="dest">The resulting encoded string will be written to this StringBuilder.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void HtmlDecodeTo(this ReadOnlySpan<char> str, StringBuilder dest)
			=> HtmlEntities.UnescapeTo(str, dest);

		#endregion

		#region Case conversion (yes, case conversion)

		/// <summary>
		/// Quickly convert the given string to lowercase, returning the original if no
		/// conversion is required (as is often the case).  This is exactly equivalent to
		/// .ToLowerInvariant(), but it's usually faster, with a special path for ASCII,
		/// and it has less GC pressure since it doesn't allocate if it doesn't have to.
		/// </summary>
		/// <param name="text">The text to convert to lowercase.</param>
		/// <returns>The same string, in lowercase.</returns>
		[MethodImpl(MethodImplOptions.AggressiveOptimization)]
		internal static string FastLowercase(this string? text)
		{
			if (string.IsNullOrEmpty(text))
				return text!;	// Nothing in, nothing out.

			unsafe
			{
				fixed (char* textBase = text)
				{
					char* end = textBase + text.Length;
					char ch;

					// First pass:  See if there are any characters that even need to be
					// corrected, as fast as possible; if not, just return the original string.
					for (char* ptr = textBase; ptr < end; ptr++)
						if ((ch = *ptr) >= 'A' && ch <= 'Z' || ch >= 128)
							goto foundUppercase;
					return text;

				foundUppercase:
					// Second pass:  We found an ASCII uppercase letter or Unicode, so this string needs
					// to be corrected.  Make a copy of the string, then stomp over its uppercase
					// letters with lowercase equivalents, as fast as possible.
					string result = new string(textBase, 0, text.Length);
					fixed (char* resultBase = result)
					{
						char* dest = resultBase;
						for (char* ptr = textBase; ptr < end;)
						{
							ch = *ptr++;
							*dest++ =
								  ch >= 'A' && ch <= 'Z' ? (char)(ch + ('a' - 'A'))
								: ch >= 128 ? char.ToLowerInvariant(ch)
								: ch;
						}
					}
					return result;
				}
			}
		}

		/// <summary>
		/// Quickly convert the given string to uppercase, returning the original if no
		/// conversion is required (as is often the case).  This is exactly equivalent to
		/// .ToUpperInvariant(), but it's usually faster, with a special path for ASCII,
		/// and it has less GC pressure since it doesn't allocate if it doesn't have to.
		/// </summary>
		/// <param name="text">The text to convert to uppercase.</param>
		/// <returns>The same string, in uppercase.</returns>
		[MethodImpl(MethodImplOptions.AggressiveOptimization)]
		internal static string FastUppercase(this string? text)
		{
			if (string.IsNullOrEmpty(text))
				return text!;   // Nothing in, nothing out.

			unsafe
			{
				fixed (char* textBase = text)
				{
					char* end = textBase + text.Length;
					char ch;

					// First pass:  See if there are any characters that even need to be
					// corrected, as fast as possible; if not, just return the original string.
					for (char* ptr = textBase; ptr < end; ptr++)
						if ((ch = *ptr) >= 'a' && ch <= 'z' || ch >= 128)
							goto foundUppercase;
					return text;

					foundUppercase:
					// Second pass:  We found an ASCII lowercase letter or Unicode, so this string needs
					// to be corrected.  Make a copy of the string, then stomp over its lowercase
					// letters with uppercase equivalents, as fast as possible.
					string result = new string(textBase, 0, text.Length);
					fixed (char* resultBase = result)
					{
						char* dest = resultBase;
						for (char* ptr = textBase; ptr < end;)
						{
							ch = *ptr++;
							*dest++ =
								  ch >= 'a' && ch <= 'z' ? (char)(ch - ('a' - 'A'))
								: ch >= 128 ? char.ToUpperInvariant(ch)
								: ch;
						}
					}
					return result;
				}
			}
		}

		#endregion

		/// <summary>
		/// Convert a normal TitleCaseIdentifier or camelCaseIdentifier into hy-phen-ized form.
		/// </summary>
		/// <param name="name">The TitleCaseIdentifier or camelCaseIdentifer to convert.</param>
		/// <returns>The equivalent hy-phen-ized form of that same identifier.</returns>
		public static string Hyphenize(this string name)
		{
			Span<char> buffer = name.Length < 64
				? stackalloc char[name.Length * 2]
				: new char[name.Length * 2];

			int dest = 0;
			char lastCh = '\0';
			foreach (char ch in name)
			{
				if (char.IsUpper(ch))
				{
					if (dest > 0 && char.IsLower(lastCh))
						buffer[dest++] = '-';
					buffer[dest++] = char.ToLower(ch);
				}
				else buffer[dest++] = ch;

				lastCh = ch;
			}

			return buffer.Slice(0, dest).ToString();
		}
	}
}
